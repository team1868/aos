"""
Rules for building typescript flatbuffers with Bazel.

AOS Note: These have diverged substantially from upstream; they should
probably just be extracted from the third_party/flatbuffers folder entirely.
"""

load("@aspect_rules_js//js:defs.bzl", "js_library")
load("@aspect_rules_ts//ts:defs.bzl", "ts_project")
load(":build_defs.bzl", "DEFAULT_INCLUDE_PATHS", "flatbuffer_library_public")

DEFAULT_FLATC_TS_ARGS = [
    "--gen-object-api",
    "--gen-mutable",
    "--reflect-names",
    "--gen-name-strings",
    "--ts-flat-files",
    "--keep-prefix",
]

def flatbuffer_ts_library(
        name,
        srcs,
        ts_files = [],
        tables = [],
        namespace = None,
        compatible_with = None,
        target_compatible_with = None,
        deps = [],
        include_paths = DEFAULT_INCLUDE_PATHS,
        flatc_args = DEFAULT_FLATC_TS_ARGS,
        visibility = None,
        restricted_to = None,
        include_reflection = False,
        package_name = None):
    """Generates a ts_library rule for a given flatbuffer definition.

    Args:
      name: Name of the generated ts_library rule.
      srcs: Source .fbs file(s).
      deps: Other flatbuffer_ts_library's to depend on. Note that currently
            you must specify all your transitive dependencies manually.
      ts_files: A list of typescript files that will be generated by this rule from the namespace
            and table of the from "<namespace>/<table>.ts" eg "aos/examples/ping.ts". Prefer the
            namespace/tables option below.
            This ends up being necessary because flatc generates separate
            files for each table, enum, struct, and union present in the
            .fbs file. This would be fine, because we could use a
            declare_directory() directive in the actual
            _flatbuffers_public_library_compile rule itself to track the
            non-predeclared outputs. *However*, the ts_project macro expects
            to know the set of typescript files being used in the macro itself
            (rather than inside of a rule), and I am not aware of any good
            method to expose the names of the contents of a declare_directory()
            directive outside of a rule implementation.
            This will have to include the full recursive dependencies of the
            rule, because it was also a pain to figure out how to make
            the ts_project rules correctly depend on each other with all of
            the include paths working out nicely.
      namespace/tables: Prettier way of specifying the ts_files by specifying
            the namespace and tables defined in the .fbs files. Tends to break
            down when we have includes in the .fbs file, since multiple
            namespaces get pulled in.
      include_paths: Optional, list of paths the includes files can be found in.
      flatc_args: Optional list of additional arguments to pass to flatc
          (e.g. --gen-mutable).
      visibility: The visibility of the generated cc_library. By default, use the
          default visibility of the project.
      compatible_with: Optional, The list of environments this rule can be built
        for, in addition to default-supported environments.
      restricted_to: Optional, The list of environments this rule can be built
        for, instead of default-supported environments.
      target_compatible_with: Optional, The list of target platform constraints
        to use.
      include_reflection: Optional, Whether to depend on the flatbuffer
        reflection library automatically. Only really relevant for the
        target that builds the reflection library itself.
      package_name: Optional, Package name to use for the generated code.
    """
    reflection_ts_files = ["reflection/%s" % (name,) for name in [
        "advanced-features.ts",
        "base-type.ts",
        "enum.ts",
        "enum-val.ts",
        "field.ts",
        "key-value.ts",
        "object.ts",
        "rpccall.ts",
        "schema-file.ts",
        "schema.ts",
        "service.ts",
        "type.ts",
    ]]
    files = reflection_ts_files if include_reflection else []
    if namespace:
        namespace_path = namespace.replace(".", "/").replace("_", "-")

        files.append(namespace_path + ".ts")
        if len(ts_files) != 0:
            fail("Only one of ts_files or the namespace/tables combination should be specified.")
        for table in tables:
            new_name = namespace_path + "/"
            started = False
            for index in range(len(table)):
                char = table[index:index + 1]
                if started and char.isupper():
                    new_name += "-"
                new_name += char.lower()
                started = True
            new_name += ".ts"
            files.append(new_name)

    else:
        files += ts_files
    srcs_lib = "%s_srcs" % (name)

    files = [name + "/" + file for file in files]

    # aos-specific modification: Add a genrule that overwrites the imports for any flatbuffer
    # types (mostly just for reflection) because they need to point to external/, not to
    # third_party/.
    # TODO(james): There absolutely are better ways to do this, but this was the quick and dirty
    # one....
    outs = ["%s_generated.ts" % (s.replace(".fbs", "").split("/")[-1]) for s in srcs]
    includes = [d + "_srcs" for d in deps] + (["@com_github_google_flatbuffers//reflection:reflection_ts_fbs_srcs"] if include_reflection else [])
    flatbuffer_library_public(
        name = srcs_lib,
        srcs = srcs,
        output_suffix = ".ts",
        output_folder = name,
        generated_files = files,
        language_flag = "--ts",
        deps = includes,
        include_paths = include_paths,
        flatc_args = flatc_args + ["--ts-no-import-ext", "--gen-all"],
        compatible_with = compatible_with,
        restricted_to = restricted_to,
        target_compatible_with = target_compatible_with,
        visibility = visibility,
    )
    ts_project(
        name = name + "_ts",
        srcs = files,
        declaration = True,
        visibility = visibility,
        compatible_with = compatible_with,
        restricted_to = restricted_to,
        target_compatible_with = target_compatible_with,
        supports_workers = 0,
        tsconfig = {
            "compilerOptions": {
                "declaration": True,
                "lib": [
                    "ES2015",
                    "ES2020.BigInt",
                    "DOM",
                ],
                "module": "es2015",
                "moduleResolution": "node",
                "strict": True,
                "types": ["node"],
            },
        },
        #deps = deps + [
        deps = [
            "//:node_modules/flatbuffers",
            # TODO(phil): Figure out why @types/node isn't being picked up as a
            # transitivie dependencies.
            "//:node_modules/@types/node",
            #] + (["@//:node_modules/flatbuffers_reflection"] if include_reflection else []),
            #] + (["@com_github_google_flatbuffers//reflection:reflection_ts_fbs"] if include_reflection else []),
        ],
    )
    js_library(
        name = name,
        visibility = visibility,
        compatible_with = compatible_with,
        restricted_to = restricted_to,
        target_compatible_with = target_compatible_with,
        srcs = [name + "_ts"],
    )
    native.filegroup(
        name = "%s_includes" % (name),
        srcs = srcs + includes,
        compatible_with = compatible_with,
        restricted_to = restricted_to,
        visibility = visibility,
    )
